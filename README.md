# Code_Chinese_to_Enghlish
我有一个梦想, 能够使用中文顺畅的开发Python, 却不会影响到正常工作. 写于 2024年3月1日 17:34分, 这个梦想有可能实现吗?

所以我现在的想法是, 开发这样一个工具, 自动从中文代码中提取出中文变量, 自动翻译成英文变量, 同时保存一个变量库, 保证每次翻译结果是稳定的.
再生成一个同功能的英文代码, 这样就可以实现, 写的时候是中文变量, 需要和其他人合作的时候, 提交给其他人看的时候, 就是一个标准的英文开发代码!

我觉得这是一个很好的梦想.

### 20240730 项目描述: 

使用中文编程, 本项目旨在将中文编程的代码自动翻译成英文.

且通过建立翻译词组映射关系的库, 来保证每次翻译的一致性和稳定性.

从而能够让我们在日常编程中使用中文进行变量命名, 并且在需要的时候可以将代码转换成英文版本, 方便工作需要.

现有一个历史变量库, 变量替换的时候, 先从本地历史变量库中进行匹配, 如果匹配不到再联网进行翻译, 并保存到变量库当中.

### 20240731 笔记:
思路, 现在应该做的是一个功能规划, 拆分.
1. 首先分析在里面都有哪些元素, 如何提取出中文变量(函数名, 类名), 提取出注释, 提取出符号等等.
    1.1 成功识别出各种元素之后, 其他的就非常简单了. 只需要用翻译接口, 或者是大模型接口, 对变量进行翻译. 然后进行替换就OK了.
2. 首先变量识别和提取. 对于替换的话, 如果直接采用 replace是否可以呢? 应该是不行, 如果一个变量名称中的一部分是另外一个变量很容易搞出问题.
3. 所以对于每个变量, 采用一个坐标的方式, 就是行数, 再加上位置. 基本上就可以定位到任何一个位置.

gpt提取变量的思路, 就是如果存在某一个变量, 那么这个变量一定是被定义过的.
但是如果是从外部引入的变量, 这种方法就不行了.
a = 5

code = re.sub(r'\b' + re.escape(var) + r'\b', translation_dict[var], code)

好的, 这行代码看起来非常有价值, \b 代表匹配单词边界, re.escape(var) 代表 var里面的特殊字符都能够被当做普通字符处理.
这样就不怕一个变量包含另外一个变量了.

引入中文变量, 有这么几种可能性: 
1. 使用语法 张三 = 22
    1.1 这种已经匹配成功了, 看来进行替换也不是什么难事
2. 使用语法 import 张三, 使用语法 import pandas as 张三, from datetime import time as 时间
   2.1 这种看起来也不是非常困难, 只需要写正则表达式, 实在不行写python代码按照规则匹配, 肯定也能搞得定.
3. 还有函数名称替换, def 某个函数()  函数中的变量 def 某个函数(变量1, 变量2) class 类名称: 
4. 貌似上面的这几种都是有固定的语法的, 也就是说替换起来应该是非常简单的. 把这几种都实现了, 变量应该就都提取好了吧.
4. 还有别的变量的可能性吗? 貌似没有了啊, 就这么简单就提取出来了.

下一步骤就是批量替换
在import from import def class 这几种定义中, 都是非常简单的, 不需要正则表达式, 直接按行处理就可以了.

20240731 18:14 现在基本上变量提取没什么问题了.
下一步就是变量替换.
首先找一个库保存一下, 需要用到数据库吗? 好像有个本地配置文件就可以了啊.

连接哪个大模型呢? 如果用Chatgpt的话, 在本地没办法直接运行啊, 得在服务器中转一下.
这个好像不用大模型也可以, 还是用吧.
有没有别的大模型啊, 国内其他大模型, 应该难度都不是特别大, 甚至本地大模型.

我部署一个http服务, 然后请求http服务, 将变量名称传入进去, 然后在服务器中获取翻译结果.
最好还是用国内的服务吧.

prompt
下面是我在编程中使用的中文变量, 请帮助我翻译成对应的英文变量名称
对于英文请直接忽略, 对于中文变量, 请将中文和英文对接的结果使用JSON格式进行返回:
['init', 'self', '小说名称', '输入文件_路径', '输出文件_路径', '读取小说内容', 'self', '小说处理器_类']


{
  "小说名称": "novel_name",
  "输入文件_路径": "input_file_path",
  "输出文件_路径": "output_file_path",
  "读取小说内容": "read_novel_content",
  "小说处理器_类": "NovelProcessor_class"
}

所以说其实就是一个 key: value的格式对吧, 那我就用json格式保存吧.

# 写入数据
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

# 读取数据
with open('data.json', 'r', encoding='utf-8') as f:
    data = json.load(f)


### 20240801:
现在就是三个函数分别提取三种变量.
然后调用大模型进行替换.

开发一个历史变量保存文件, 可以先检查文件是否存在, 如果不存在则创建文件, 然后读取该文件, 读入字典.
如果历史上已经存在过的变量, 则直接保存.


# 替换变量名
for var in variables:
    if var in translation_dict:
        code = re.sub(r'\b' + re.escape(var) + r'\b', translation_dict[var], code)

print(code)

### 20240801: 
"发送邮件": "send_email",
"发送邮箱": "send_email",
发现了一个小bug, 发送邮箱和发送邮件, 被翻译成了相同的英文, 导致出现了冲突.
这里虽然存在 发送邮箱 翻译不准确, 但是不得不防备以后还可能出现这种状况, 那么应该如何翻译呢? 

首先, 如果在一个代码变量中存在两个变量, 但是被翻译成一种英文.
其次, 如果在历史变量中存在A, 翻译成B. 然后又出现变量C, 也被翻译成了B.
这两种都有可能产生冲突.

对于第一种, 我没办法控制大模型的翻译结果, 只能在大模型翻译后, 自行检查是否存在重复的, 如果存在重复的, 
则将重复的收集起来发送给大模型进行修改.

然后再对修改后的结果替换原来的.

对于第二种, 首先历史变量检查时不会触发, 因为是新变量, 但是翻译后, 进行合并之后, 也是要进行检查.
所以两者是相同的, 都是要进行检查, 如果存在重复则重新修改.

20240801: 
发现了新的问题, 当import引用的是一个中文名称的py文件时, 这时候如果直接翻译成英文.
但是这个英文文件不存在, 就会出现错误.

应该将这个中文文件也关联性的进行处理, 调用该代码进行替换, 并且这个文件名称也应该保存到变量库当中去, 
保证两次替换的文件和代码中的变量可以替换成相同的值.

而且这个py文件当中的函数也会进行替换, 那么两者必须保证替换的是一致的才可以.
OK对了, 这个需要考虑啊.

也就是替换实际上不是一个文件的替换, 而是一系列关联性文件的整体替换, 才能保证替换成英文之后的代码可以正常运行.
有意思.


with open(merged_file_name, "w") as 文件:
这个和for
import
from 应该放在一起.
这个也需要处理


### 20240802: 
暂时能翻译的都翻译了, 
后面还有的就是关联文件翻译.
在翻译文件名称的时候, 将文件名称也保存到变量当中去, 保证翻译结果的统一.
import 通义千问大模型
提取出通义千问大模型, 找到通义千问大模型.py文件, 然后对这个文件进行翻译.
在这个文件当中, 也寻找import 中的其他中文文件, 如果是中文的, 则进行翻译, 如果是英文名称则不进行翻译.

如果在当前文件夹找不到, 或者当前项目当中找不到, 则说明不需要翻译.

### 20240804
今天终于来干点正事了, 我应该修改我的时间方面的思考啊, 如何让自己能够集中注意力干点有用的事情.
不能只通过工作这一件事来赚钱, 一定要在搞点别的事情啊!

梳理一下, 当前这个功能已经进展到什么程度了? 
对了

-[x] 引入logru记录日志, 别再用print打印了, 并不好用
-[x] 发现大模型会偷懒, 有的单词就跳过了, 没有进行翻译, 翻译之后再检查一遍是否所有的都返回了.

函数名称, function_argument_name = one

发现对于这种没有匹配上, 也就是说可以用多个变量, 解包一个多元素变量.

下面开发新的重量级功能, 关联翻译.
简单的地方是, 变量反正都统一存在一个文件里面.
直接从里面搜索就可以.
然后找到的文件名称, 








