思路: 

首先还是一样的, 先搞几个英文的代码读一下.
我的目标有两个, 一个是单纯为了更好的阅读代码而使用.
另外一个是真的将项目翻译成中文, 让我可以在此基础上进一步开发项目.

首先先以第一个为思考, 

from import 中的变量, 首先判断是否在项目当中的, 如果在项目当中, 那么翻译成中文, 没商量.
如果不在项目当中, 应该就是引入的第三方的, 第三方的暂时不翻译, 如果是单纯为了阅读也可以翻译.

函数名称, 翻译.
函数参数, 翻译.

内置函数: 其实不用翻译, 基本上都比较熟悉, 但是也可以翻译一下. 我的那个项目拓展内容.

设置变量, 翻译.
基本上就是那几种, 我都开发过了, 还有就是判断import中的用不用翻译了.

注释: 也翻译.
如果是字符串呢, 不能随便翻译, 否则项目可能没办法运行.

英文和中文是否也需要唯一对应性, conf config如果都翻译成配置, 可能会存在问题啊.

必须得保证对应的唯一性, config如何翻译成配置, conf 可以翻译成 设置?

首先几个变量提取功能, 如果里面含有中文变量? 则不需要翻译, 但是可能性非常非常小.

忘记了, 昨天好像是翻译一个可以了, 但是我


- [ ] 两种思路, 一种是极限翻译, 不管代码能不能阅读, 只要都翻译成中文, 但是这样也不行, 因为代码阅读, 需要跟踪代码.
如果全给翻译了, 就注定不能找到原来的代码了.
所以即使代码不能运行了, 也还是应该能够跟踪代码, 也就是如果一个引入的代码翻译了, 那么他引入的原代码也应该对应的进行翻译.

- [x] 判断import和from语法中哪些需要翻译, 哪些不需要翻译.
import os import 操作系统
这个的话应该不进行翻译, 
思路是, 如果一个import的变量, 那么判断这个变量是不是, 在本项目当中存在.
如果是在本项目中存在的代码, 那么进行翻译, 将当前变量翻译, 然后再对关联的文件进行翻译.

有没有单独代码翻译, 还是完整项目翻译.
还是两个思路, 单独代码翻译就必须翻译关联的.
完整的项目翻译更合理一些.

应该是遍历目录, 将所有的项目内文件都记录下来, 然后翻译的时候从这里面判断是否存在这个文件, 从而判断该文件是否翻译.

from .haha import open_ai_session
from ..hehe import open_ai_bot
from .. import fuck
from ...linkai import link_ai_bot

from ... import test


### 20240825:
今天完成了单个文件翻译, 但是还没有彻底完成, 关键功能算是完成了.
接下来应该进行整个项目的翻译工作.

- [ ] 注释翻译

### 20240826:
- [x] 目录批量翻译

单个文件的翻译功能, 先这样吧.
搞整个项目翻译, 首先是文件夹的翻译, 遍历获取文件夹.

先搞个整个项目翻译吧, 
1. 指定翻译路径, 复制整个项目到新路径.
复制文件夹_删除已存在(项目_根路径, 项目_翻译路径)
/Users/yangxinyi/Downloads/200_临时文件夹/english_test_project
/Users/yangxinyi/Downloads/200_临时文件夹/英文测试项目
这部分代码存在问题, 下次进行解决: 
        # 当没有翻译成功, 两个目录相同时, 如何处理?
        if 判断中文变量(项目_纯英文目录表单.loc[索引, "中文变量"]):
            if not os.path.exists(创建目录):
                os.rename(原目录, 创建目录)  # 将中文文件夹重命名成英文文件夹
            else:
                复制文件_覆盖(原目录, 创建目录)
                shutil.rmtree(原目录)

FileNotFoundError: [Errno 2] No such file or directory: '/Users/yangxinyi/Downloads/200_临时文件夹/英文测试项目//channel/wechatmp' -> '/Users/yangxinyi/Downloads/200_临时文件夹/英文测试项目//channel/微信公众号'

这是因为channel实际上在上面的过程已经改变中文名称了, 但在子文件夹中却没有生效
18 channel   通道
25 wechatmp  微信公众号

找到bug原因:
/channel
/channel/wechat
/channel/wechatmp
当循环到wechat时, 内循环到wechatmp, 判断为是上面的子目录, 所以进行了替换.
其他的也有这种可能, 所以这种语法判断子目录并不准确, 包括原来的中文翻译代码也可能存在这个bug.
修复思路: 

### 20240827:
- [ ] 代码批量翻译

OK, 目录已经翻译完成了, 接下来搞代码翻译.
和原来的思路也是一样的.
不对, 如果一个单词要翻译, 就应该整个项目翻译.

如果说在项目中有某个文件夹 channel, 又有一个第三方包channel.
那么在不同的代码中, 如果 from channal import x
channal 有可能是项目内的包, 也有可能是第三包的包, 应该如何判断呢? 

导入有两种可能, 第一种是相对导入, 可能有.
这种一定是项目内部的.

第二种是 import channel
这种则有两种可能, 如果是项目内部的库, 那么channel一定是在当前根目录当中.
不可能是相对路径, 所以只需要判断根目录中是否存在就可以了.

批量翻译了文件夹, 也可能翻译了py文件, 然后翻译某个代码的时候, 可能用到了
所以遍历了目录, 遍历了文件, 那么这个目录和这个文件都保存两个信息, 一个是当前的, 一个是翻译之前的.
这样一来就可以了, 这需要记录下来哪些被翻译了, 哪些没有被翻译过.
中文也可能没有被翻译过啊, 精准的话就是这样, 将所有翻译的数据保留下来, 在翻译文件的时候, 进行判断.

上次搞到哪里来着? 我记得应该是还有错误没有解决? 

### 20240829:

- [ ] 新发现一个问题, class Config(dict):
如果一个类, 继承的是内置函数的父类, 或者第三方包的父类, 那么如果对类里面定义的函数进行翻译, 将会导致这个类, 
和父类无法对应, 导致代码失效, 基本上就不用指望代码还能运行了.

这种要不要单独排除呢? 

如果单独排除的话, 应该先提取父类名称, 然后判断父类是不是项目内部的类, 还是外部的类.
如果是非项目的类, 就对整个类中的变量, 不进行翻译. 正常是要对父类进行覆盖, 那这里我翻译了就相当于不覆盖父类的功能, 相当于一个新的功能, 
这好像也是可以的啊!
这种先不管, 先翻译, 后面再处理错误.

但是系统变量 __xxx__ 这种不要翻译了.

- [ ] 变量提取中提取到了错误的数据:
{'storing_log': '存储日志', 'storing log': '存储日志', 'advanced_uses': '高级用法', 'advanced uses': '高级用法'}
有时间排查一下原因.

- [ ] 重复变量冲突: "线路": "channel","通道": "Channel",
这个错误出现的原因, 第一次出现channel的时候, 翻译成了通道.
第二次出现了Channel, 大模型也翻译成了通道, 但是两个单词重复了, 这样就重新调整, 
将前边的channel改成了线路, 后面的Channel变成通道.
但是前边遇到channel已经翻译成了"通道", 和后面翻译的线路没有达成一致.

解决: 前边已经翻译了线路, 那么应该保持不变
1. 就是记录原来的和新增的重复, 只改变新增的, 原来的不动, 但是如果不将两个重复的都告诉大模型, 只是让大模型改成另外一个吗, 感觉不太好啊.
2. 或者是先不进行翻译, 先进行批量的变量提取, 所有变量都提取完了, 再统一进行翻译, 这样就可以避免了.

第二个要考虑的是, 英文中存在大小写, 但是中文不存在.
如果是翻译成不同的单词, 肯定不合适. "线路": "channel","通道": "Channel"
还是添加一个标识符, 进行区分.
channel 通道
Channel 通道_类



'ATTACHMENT': '附件', 'attachment'
如果一个单词全部是大写, 一般都用作常量, 附件_常量

如果一个单词开头是大写: 一般用作类  通道_类

'imageDir': '图片目录', 'picDir': '图片目录'

filename FileName fileName Filename FILENAME 都会被翻译成文件名, 怎么办呢? 

rval  ReturnValue  返回值 中文也没有这种缩写的写法.

解决方案: 
1. 判断如果单词开头一个字母是大写的, 则在后面添加类.
2. 如果单纯整个都是大写的, 则在后面添加常量.
3. 对所有代码, 先提取变量, 变量提取完成了, 再统一进行替换.

- [x] from plugins import * 这种导入变量的处理.
思路已经很清楚了, 对于这种方式导入的变量, 如果plugins是py文件, 就把这个py文件当中的变量全部引入进来.
如果是工具包, 就将__init__作为变量引入进来, __init__这个不能进行翻译, 应该进行保留.
所有__xxx__都应该进行保留.

channel 通道
Channel 通道_类

- [x] 所有__xxx__都应该进行保留, 这个先处理.
Channel 通道_类
CHANNEL 通道_常量
今天把这几个搞定.

- [ ] 插件集合里面的 __init__ 文件消失了
- __init__ 这类不进行翻译.


- [ ] 一次翻译以前多单词, 每次传入100个, 速度太慢, 可以使用多线程进行优化.
搞15个线程, 就可以一次性翻译完成, 极大的节省时间.

- [x] 好像英文变量没有过滤字符串之类的, 这部分应该需要调整
''' add or invite member into chatroom
     * there are two ways to get members into chatroom: invite or directly add
     * but for chatrooms with more than 40 users, you can only use invite
     * but don't worry we will auto-force userInvitation for you when necessary
    '''


- [ ] 发现对所有符合的变量都添加 _类, 并不合理, 一个是别人开发代码不一定这么规范.
然后py代码文件名称如何用的是这样的变量, 岂不是也给翻译成了 xxx_类
还是的根据这个变量是在哪里提取的, 然后进行处理.
所有根据class, def 文件名, 不同地方提取出来的变量, 进行不同的名称处理, 这样应该是更合理的.























