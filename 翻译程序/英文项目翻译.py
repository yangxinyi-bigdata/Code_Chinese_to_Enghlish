from 翻译程序.git管理 import Git管理
from 翻译程序.通用处理 import *
import shutil

关联文件_列表 = []
中英映射变量_路径 = "翻译程序/中英映射字典.json"
dir_path = os.path.dirname(os.path.realpath(__file__))
已保存变量_路径 = os.path.join(dir_path, "翻译程序", "中英映射字典.json")
# 已保存变量_路径 = "翻译程序/中英映射字典.json"


def 关联文件判断(项目绝对路径):
    """函数功能:
    公共列表, 关联文件_列表 中保存着import的其他文件,

    from 示例代码 import 案例1
    from 通义千问大模型 import 翻译中文变量
    import 示例代码.nover_send
    import 示例代码
    import 通义千问大模型

    分别会获取变量 示例代码, 案例1, 通义千问大模型, 翻译中文变量
    然后我需要判断这几个变量, 到底代表一个包, 还是一个py文件.

    可以把整个项目, 遍历所有文件名, 这样就知道了, 是否在当前项目当中.如果在肯定优先当前项目文件.
    1. 判断改文件名中是否包含中国字
    2. 如果包含中国字, 再判断该文件是否在当前项目当中, 如果在当前项目当中, 再判断是目录还是py文件.
    如果是目录, 则批量替换"""
    关联中文文件_列表 = 过滤中文变量(关联文件_列表)
    日志.debug("关联中文文件_列表: {}", 关联中文文件_列表)
    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目绝对路径)  # 收集_目录列表 收集_文件列表
    # 对 关联中文文件_列表 中的进行判断
    日志.debug("收集_目录列表: {}", 收集_目录列表)
    日志.debug("收集_文件列表: {}", 收集_文件列表)
    目录名称映射字典 = {}
    for 完整目录 in 收集_目录列表:
        目录名称 = 完整目录.split("/")[-1]
        目录名称映射字典[目录名称] = 完整目录

    文件名称映射字典 = {}
    for 完整文件 in 收集_文件列表:
        文件名称 = 完整文件.split("/")[-1]
        文件名称映射字典[文件名称] = 完整文件

    for 中文变量 in 关联中文文件_列表:
        # /Users/yangxinyi/Library/CloudStorage/OneDrive-个人/100_code/Code_Chinese_to_Enghlish/示例代码/__init__.py
        # 注意这里面提取出的中文变量, 很可能并没有运行.
        if 中文变量 in 目录名称映射字典.keys():  # 目录
            # 在同一层级, 创建一个文件夹
            目录映射字典 = 通义千问模型.翻译文件名(中文变量)
            翻译英文名称 = 目录映射字典[中文变量]
            完整目录 = 目录名称映射字典[中文变量]
            上层目录 = 完整目录[:-len(中文变量)]
            日志.debug(上层目录 + 翻译英文名称)
            os.mkdir(上层目录 + 翻译英文名称)


        elif 中文变量 in 收集_文件列表:
            # 传到递归函数里面再次进行处理
            # todo
            pass





def 处理重复项(检测变量映射):
    重复项 = 检测字典重复值(检测变量映射)
    if 重复项:
        日志.debug("检测到重复项: {}", 重复项)

        去重字典 = 通义千问模型.处理英文重复变量(重复项)
        日志.debug("大模型去重后: {}", 去重字典)
        # 去重后的字典应该, 把这些值覆盖原来的key和value
        return 去重字典
    else:
        日志.debug("未检测到重复项")
    # 翻转成 中 -> 英 后再保存


def 查询英文变量_V1(英文变量列表):
    """V2改版, 主要是从之前读取一个 中英配置, 然后再翻转, 改成了直接使用 英中配置, 不再直接去重处理.
    # 现在是获取到了一个集合, 我需要获取已保存变量, 这是一个字典, 然后
    :param 变量位置, 文件名称, 类名, 函数名, for循环, 等关键字, 根据不同的位置进行不同的处理
    """
    已保存变量 = 读取中英映射变量()
    英文变量字典 = 翻转字典_调转(已保存变量)

    英文变量列表 = [元素 for 元素 in 英文变量列表 if len(元素) > 1]

    # 有一个集合和一个字典, 现在需要从集合中提取出所有不在字典的key当中的数据
    未保存变量 = [元素 for 元素 in 英文变量列表 if not 英文变量字典.get(元素)]
    # 考虑未保存变量为空的情况, 不需要连接大模型
    if 未保存变量:
        # 如果要翻译的变量超过500个, 则进行切割后分批次翻译
        新变量_字典 = 通义千问模型.翻译英文变量(未保存变量)
        新变量_字典 = 变量名称处理(新变量_字典)

        # 发现这里大模型返回的字典有可能存在, 部分传入的变量没有翻译回来, 这里添加一个缺失检测功能
        # 如何检测呢? 未保存变量是我要查询的变量, 新变量_字典 查询这个key里面不存在的 未保存变量 元素
        缺失变量 = [元素 for 元素 in 未保存变量 if not 新变量_字典.get(元素)]

        if 缺失变量:
            日志.debug("查询到缺失变量: {}", 缺失变量)
            缺失变量翻译_字典 = 通义千问模型.翻译英文变量(缺失变量)
            缺失变量翻译_字典 = 变量名称处理(缺失变量翻译_字典)
            新变量_字典.update(缺失变量翻译_字典)
        新变量_字典.update(英文变量字典)  # 放在后面的是保留的, 历史变量优先级更高

        # 这里遇到 `传入大模型返回JSON`被大模型变成了 `传入大模型返回_json`, 导致翻译缺失key.
        # 考虑这里可能出现大模型没有将传入的英文变量key, 按照原样进行返回, 进行一个检测
        # 如何处理呢? 再次检测是否存在缺失, 如果存在缺失则换成单独翻译添加进去.

        缺失变量 = [元素 for 元素 in 未保存变量 if not 新变量_字典.get(元素)]
        if 缺失变量:
            日志.debug("第二次查询到缺失变量: {}", 缺失变量)
            缺失变量翻译_字典 = 通义千问模型.翻译英文文件名(缺失变量)
            缺失变量翻译_字典 = 变量名称处理(缺失变量翻译_字典)
            新变量_字典.update(缺失变量翻译_字典)

        合并后变量 = 新变量_字典
    else:
        合并后变量 = 英文变量字典

    # 到这里已经翻译完成了, 但是考虑到两个英文可能会被翻译成相同的中文, 这里需要做一个重复检测
    # 需要翻转吗?
    翻转字典 = 翻转字典_变成列表(合并后变量)
    重复项 = 检测字典重复值(翻转字典)
    if 重复项:
        日志.debug("检测到重复项: {}", 重复项)
        去重字典 = 通义千问模型.处理英文重复变量(重复项)
        日志.debug("大模型去重后: {}", 去重字典)
        # 去重后的字典应该, 把这些值覆盖原来的key和value
        合并后变量.update(去重字典)
    else:
        日志.debug("未检测到重复项")
    # 翻转成 中 -> 英 后再保存

    合并后变量_中英 = 翻转字典_调转(合并后变量)
    保存中英变量(合并后变量_中英)
    return 合并后变量

def 查询英文文件变量(英文变量列表):
    """单独用于处理文件变量?
    先试一下看看成不成
    :param
    """
    已保存变量 = 读取中英映射变量()
    英文变量字典 = 翻转字典_调转(已保存变量)

    英文变量列表 = [元素 for 元素 in 英文变量列表 if len(元素) > 1]

    # 有一个集合和一个字典, 现在需要从集合中提取出所有不在字典的key当中的数据
    未保存变量 = [元素 for 元素 in 英文变量列表 if not 英文变量字典.get(元素)]
    # 考虑未保存变量为空的情况, 不需要连接大模型
    if 未保存变量:
        # 如果要翻译的变量超过500个, 则进行切割后分批次翻译
        新变量_字典 = 通义千问模型.翻译英文变量(未保存变量)
        新变量_字典 = 变量名称处理(新变量_字典)

        # 发现这里大模型返回的字典有可能存在, 部分传入的变量没有翻译回来, 这里添加一个缺失检测功能
        # 如何检测呢? 未保存变量是我要查询的变量, 新变量_字典 查询这个key里面不存在的 未保存变量 元素
        缺失变量 = [元素 for 元素 in 未保存变量 if not 新变量_字典.get(元素)]

        if 缺失变量:
            日志.debug("查询到缺失变量: {}", 缺失变量)
            缺失变量翻译_字典 = 通义千问模型.翻译英文变量(缺失变量)
            缺失变量翻译_字典 = 变量名称处理(缺失变量翻译_字典)
            新变量_字典.update(缺失变量翻译_字典)
        新变量_字典.update(英文变量字典)  # 放在后面的是保留的, 历史变量优先级更高

        # 这里遇到 `传入大模型返回JSON`被大模型变成了 `传入大模型返回_json`, 导致翻译缺失key.
        # 考虑这里可能出现大模型没有将传入的英文变量key, 按照原样进行返回, 进行一个检测
        # 如何处理呢? 再次检测是否存在缺失, 如果存在缺失则换成单独翻译添加进去.

        缺失变量 = [元素 for 元素 in 未保存变量 if not 新变量_字典.get(元素)]
        if 缺失变量:
            日志.debug("第二次查询到缺失变量: {}", 缺失变量)
            缺失变量翻译_字典 = 通义千问模型.翻译英文文件名(缺失变量)
            缺失变量翻译_字典 = 变量名称处理(缺失变量翻译_字典)
            新变量_字典.update(缺失变量翻译_字典)

        合并后变量 = 新变量_字典
    else:
        合并后变量 = 英文变量字典

    # 到这里已经翻译完成了, 但是考虑到两个英文可能会被翻译成相同的中文, 这里需要做一个重复检测
    # 需要翻转吗?
    翻转字典 = 翻转字典_变成列表(合并后变量)
    重复项 = 检测字典重复值(翻转字典)
    if 重复项:
        日志.debug("检测到重复项: {}", 重复项)
        去重字典 = 通义千问模型.处理英文重复变量(重复项)
        日志.debug("大模型去重后: {}", 去重字典)
        # 去重后的字典应该, 把这些值覆盖原来的key和value
        合并后变量.update(去重字典)
    else:
        日志.debug("未检测到重复项")
    # 翻转成 中 -> 英 后再保存

    合并后变量_中英 = 翻转字典_调转(合并后变量)
    保存中英变量(合并后变量_中英)
    return 合并后变量


def 函数_替换代码变量(代码文本, 变量映射, 引号=0):
    """引号:
    1: 开启引号中的中文匹配

    0: 去掉引号中的中文提取
    """
    # 匹配注释部分
    注释匹配模式 = r'(#.*?)\n'
    # 识别所有的字符串部分 (包括单引号和双引号, 以及单行和多行字符串)
    字符串匹配模式 = r'(\"\"\".*?\"\"\"|\'\'\'.*?\'\'\'|\".*?\"|\'.*?\')'
    # 修改为跨行匹配模式
    多行字符串匹配模式 = r'(\"\"\".*?\"\"\"|\'\'\'.*?\'\'\')'

    # 用于替换的回调函数
    def 替换函数(匹配结果):
        匹配文本 = 匹配结果.group(0)
        if 匹配文本.startswith(('"', "'", "#")):
            # 如果是字符串（包括多行字符串），直接返回不做替换
            return 匹配文本
        else:
            # 如果是变量名，根据映射进行替换
            return 变量映射.get(匹配文本, 匹配文本)

    # 构造变量名的正则表达式 (注意这里使用了 \b 进行词边界匹配)
    变量匹配模式 = r'\b(' + '|'.join(re.escape(中文变量) for 中文变量 in 变量映射.keys()) + r')\b'

    if not 引号:
        # 合并字符串匹配模式和变量匹配模式
        综合匹配模式 = 注释匹配模式 + r'|' + 多行字符串匹配模式 + r'|' + 字符串匹配模式 + r'|' + 变量匹配模式
    else:
        综合匹配模式 = 注释匹配模式 + r'|' + 多行字符串匹配模式 + r'|' + 变量匹配模式

    # 使用 sub 函数进行替换，结合字符串的保护
    代码文本 = re.sub(综合匹配模式, 替换函数, 代码文本, flags=re.DOTALL)

    return 代码文本

def 函数_替换from变量(代码文本, 变量映射, 引号=0):
    """引号:
    1: 开启引号中的中文匹配

    0: 去掉引号中的中文提取

    变量映射: {'baidu': ('百度', 32, 5), 'bot': ('机器人', 26, 5), 'common': ('通用', 10, 5), 'tmp': ('临时', 15, 5), 'translate': ('翻译', 32, 5)}
    """
    for 变量 in 变量映射:
        翻译变量 = 变量映射[变量][0]
        行号 = 变量映射[变量][1]
        本行代码 = 代码文本[行号]
        # 替换本行代码

    # 匹配注释部分
    注释匹配模式 = r'(#.*?)\n'
    # 识别所有的字符串部分 (包括单引号和双引号, 以及单行和多行字符串)
    字符串匹配模式 = r'(\"\"\".*?\"\"\"|\'\'\'.*?\'\'\'|\".*?\"|\'.*?\')'
    # 修改为跨行匹配模式
    多行字符串匹配模式 = r'(\"\"\".*?\"\"\"|\'\'\'.*?\'\'\')'

    # 用于替换的回调函数
    def 替换函数(匹配结果):
        匹配文本 = 匹配结果.group(0)
        if 匹配文本.startswith(('"', "'", "#")):
            # 如果是字符串（包括多行字符串），直接返回不做替换
            return 匹配文本
        else:
            # 如果是变量名，根据映射进行替换
            return 变量映射.get(匹配文本, 匹配文本)

    # 构造变量名的正则表达式 (注意这里使用了 \b 进行词边界匹配)
    变量匹配模式 = r'\b(' + '|'.join(re.escape(变量) for 变量 in 变量映射.keys()) + r')\b'

    if not 引号:
        # 合并字符串匹配模式和变量匹配模式
        综合匹配模式 = 注释匹配模式 + r'|' + 多行字符串匹配模式 + r'|' + 字符串匹配模式 + r'|' + 变量匹配模式
    else:
        综合匹配模式 = 注释匹配模式 + r'|' + 多行字符串匹配模式 + r'|' + 变量匹配模式

    # 使用 sub 函数进行替换，结合字符串的保护
    代码文本 = re.sub(综合匹配模式, 替换函数, 代码文本, flags=re.DOTALL)

    return 代码文本

def ipynb转换成py(notebook):
    py_代码 = ""
    md_文本 = ""
    for cell in notebook['cells']:
        if cell['cell_type'] == 'code':
            code = ''.join(cell['source'])
            py_代码 += code + '\n'

        elif cell['cell_type'] == 'markdown':
            # 将 Markdown 内容转换为注释
            comments = ''.join(cell['source'])
            # 转换每一行为注释形式
            comment_lines = comments.splitlines()
            for line in comment_lines:
                py_代码 += '# ' + line + '\n'
    return py_代码


def 提取代码属性(代码相对路径, 项目_根路径):
    代码_绝对路径 = 项目_根路径 + 代码相对路径

    with open(代码_绝对路径, "r") as 文件:
        代码文本 = 文件.read()

    # 保存修改后英文代码, 保存在同一个路径, 文件名称, 原来的中文文件名称翻译成一个英文的文件名称
    代码所在目录 = os.path.dirname(代码相对路径)
    代码所在目录 = "" if 代码所在目录 == "/" else 代码所在目录
    # 提取文件名部分
    文件名 = os.path.basename(代码相对路径)
    文件名前缀, 文件名后缀 = 文件名.split(".")
    return 文件名前缀, 文件名后缀, 文件名, 代码所在目录, 代码文本


def 代码变量提取(原代码路径, 项目_根路径, 项目_文件表单, 项目_目录表单):
    # 判断表单是是否已经提取过了
    # 这里需要用代码相对路径, 从表格里面去提取这个数据
    提取变量_集合 = 项目_文件表单.loc[项目_文件表单.英文相对路径 == 原代码路径, "翻译英文变量"].iloc[0]
    if 提取变量_集合:
        return 提取变量_集合

    文件名前缀, 文件名后缀, 文件名, 原代码所在目录, 代码文本 = 提取代码属性(原代码路径, 项目_根路径)
    日志.debug("当前提取变量 代码相对路径: {}", 原代码路径)

    # 收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)
    # 收集_相对目录列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_目录列表]  # 有了创建文件夹之后的, 目录列表, 如何判断呢?
    # 收集_相对文件列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_文件列表]
    # 这里已经有了项目_文件表单, 所以不再需要获取项目目录和文件列表了, 直接用 项目_文件表单 就可以了吧
    代码文本 = 删除代码注释和字符串(代码文本)
    变量列表 = []
    变量列表1 = 匹配代码定义变量(代码文本)
    变量列表_key, 变量_as = 提取导入变量_通用(代码文本)
    # os 首先判断当前代码所在目录中是否存在 os文件夹, 或者os.py, 如何代码相对目录是plugins, 就在plugins中搜索
    # 这里面出现新的情况, 很可能原来的文件夹已经被翻译成中文了, 需要重新判断
    变量列表2_项目内 = []
    for 导入变量 in 变量列表_key:
        # 判断有没有. 如果有一个, 就只需要判断当前文件夹, 如果有两个就只需要判断上层文件夹
        # 'bot.xunfei.abcd.haha' 还要考虑这种情况
        # from bot.xunfei.abcd.haha import open_ai_bot 对于这种情况需要调整open_ai_bot的路径判断
        # 在这里注意的是上层路径已经翻译, 但是当前代码import还是纯英文, 要用英文判断
        match = re.match(r"\.*", 导入变量)
        点数量 = len(match.group(0)) if match else 0
        导入变量_去点 = 导入变量[点数量:]
        导入路径 = "/" + 导入变量_去点.replace(".", "/")  # 例如 threading, 就是 /threading

        def 处理导入(导入变量_去点):
            if 导入变量_去点.count(".") > 0:
                变量列表2_项目内.extend(导入变量_去点.split("."))
            else:
                变量列表2_项目内.append(导入变量_去点)

        if 点数量 > 0:  # 如果前边有点, 则肯定是项目内部的
            # 导入目录 = 代码相对目录.rsplit("/", maxsplit=点数量 - 1)[0]  # 这里根据代码位置计算实际导入路径, 但好像没用, 知道是内部的, 直接翻译就可以了
            if 原代码所在目录 + 导入路径 in 项目_目录表单.相对路径.values:  # 同文件夹包
                处理导入(导入变量_去点)
                找到路径 = "相对目录"
            elif 原代码所在目录 + 导入路径 + ".py" in 项目_文件表单.英文相对路径.values:  # 同文件夹py代码
                处理导入(导入变量_去点)
                找到路径 = "相对py"
            else:  # 都没找到
                找到路径 = False

        else:  # 没有点就两种可能, 当前目录和根目录, 因为导入路径已经处理, 所以不需要判断是否包含点, 都可以正确执行

            if 原代码所在目录 + 导入路径 in 项目_目录表单.相对路径.values:  # 同文件夹包
                处理导入(导入变量_去点)
                找到路径 = "相对目录"
            elif 原代码所在目录 + 导入路径 + ".py" in 项目_文件表单.英文相对路径.values:  # 同文件夹py代码
                处理导入(导入变量_去点)
                找到路径 = "相对py"
            elif 导入路径 in 项目_目录表单.相对路径.values:  # 根文件夹包
                处理导入(导入变量_去点)
                找到路径 = "绝对目录"
            elif 导入路径 + ".py" in 项目_文件表单.英文相对路径.values:  # 根py代码
                处理导入(导入变量_去点)
                找到路径 = "绝对py"
            else:  # 都没找到
                找到路径 = False


        #  from xxx import yyy 这行代码意思是如果找到了 xxx, 那么yyy一定也是项目内部的, 直接添加进来
        if 找到路径:
            if 变量列表_key[导入变量] == ["*"]:  # 批量导入的, 关联文件中的变量也需要引入
                # 添加逻辑, 到from a import b 时, b如果是*, 则代表一个批量导入, 那么 a当中的所有变量, 都需要引入进来
                # 判断前边是 包还是py代码
                if 找到路径 == "相对目录":
                    导入代码_相对路径 = 原代码所在目录 + 导入路径 + "/__init__.py"
                elif 找到路径 == "绝对目录":
                    导入代码_相对路径 = 导入路径 + "/__init__.py"
                elif 找到路径 == "相对py":
                    导入代码_相对路径 = 原代码所在目录 + 导入路径 + ".py"
                elif 找到路径 == "绝对py":
                    导入代码_相对路径 = 导入路径 + ".py"
                # 那么该目录中一定应该有__init__, 如果没有 __init__ , 导入是没用的
                # 一个代码可能会被重复提取多次, 这里提取出来的可以保存到 项目_文件表单里面,
                # 判断是否已经提取过, 如果提取过则直接从表单里面提取即可.
                关联变量_提取 = 代码变量提取(导入代码_相对路径, 项目_根路径, 项目_文件表单, 项目_目录表单)
                变量列表.extend(关联变量_提取)
            else:
                变量列表2_项目内.extend(变量列表_key[导入变量])

    # 判断是项目内文件, 还是导入的库, 如果导入的是库则不进行翻译
    # from xxx import yyy  xxx可能是一个目录, xxx可能是一个py文件, 当xxx是目录, yyy是py文件, 当xxx是文件, yyy是变量, 如果是变量则不需要考虑
    # 所以有from先判断from, from找到了, 不用在找import. from没有找到, 再找import.
    # import xxx, 这种xxx如果是一个目录, 实际就是__init__, 或者xxx是一个文件
    # 所以就都判断就可以了, 变量列表2, 当中的所有变量, 匹配
    # 要不要考虑具体路径呢? 还是只要能找到就翻译? 只要在项目当中能找到这个变量就进行翻译? 还是要考虑到底符不符合路径呢?
    # 一个是从根据路进行判断, 一个是从 代码所在目录, 一个是从根目录开始匹配

    变量列表3 = 固定语法匹配(代码文本)
    变量列表.extend(变量列表1)
    变量列表.extend(变量列表2_项目内)
    变量列表.extend(变量列表3)
    提取变量_集合 = set(变量列表)
    # 过滤掉 __变量__ 这种形式的变量
    提取变量_集合_过滤 = {变量 for 变量 in 提取变量_集合 if not (变量.startswith("__") and 变量.endswith("__"))}

    return 提取变量_集合_过滤


def 代码文件翻译_V1(代码相对路径, 项目_根路径, 英中变量映射, 英文变量字典):
    文件名前缀, 文件名后缀, 文件名, 代码所在目录, 代码文本 = 提取代码属性(代码相对路径, 项目_根路径)
    日志.debug("当前翻译代码 代码相对路径: {}", 代码相对路径)

    # 替换只需要替换 `中文变量列表` 中的就可以了, 需要一个映射关系
    代码文本 = 函数_替换代码变量(代码文本, 英中变量映射)

    # 这里有可能文件名早就在已保存变量里面已经有了, 就不再需要翻译了.
    if 文件名前缀 not in 英文变量字典:
        文件名前缀_翻译字典 = 通义千问模型.翻译英文变量(文件名前缀)
        文件名前缀_翻译结果 = 文件名前缀_翻译字典[文件名前缀]
        翻译代码_保存路径 = 项目_根路径 + 代码所在目录 + "/" + 文件名前缀_翻译结果 + "." + 文件名后缀
        with open(翻译代码_保存路径, "w") as f:
            f.write(代码文本)
        # 将翻译的结果也保存到变量中
        return {文件名前缀: 文件名前缀_翻译结果}
    else:
        文件名前缀_翻译结果 = 英文变量字典[文件名前缀]
        翻译代码_保存路径 = 项目_根路径 + 代码所在目录 + "/" + 文件名前缀_翻译结果 + "." + 文件名后缀
        with open(翻译代码_保存路径, "w") as f:
            f.write(代码文本)


def 代码文件翻译_V2(代码_绝对路径):
    """升级成直接匹配中文变量
    可以自动根据传入的是py还是ipynb来分别进行处理"""
    if 代码_绝对路径.endswith(".py"):
        代码类型 = "py"
    elif 代码_绝对路径.endswith(".ipynb"):
        代码类型 = "ipynb"

    if 代码类型 == "py":
        with open(代码_绝对路径, "r") as 文件:
            代码文本 = 文件.read()
    elif 代码类型 == "ipynb":
        with open(代码_绝对路径, 'r', encoding='utf-8') as file:
            notebook = json.load(file)
            代码文本 = ipynb转换成py(notebook)

    中文变量_集合 = 提取中文变量(代码文本)
    # 变量列表1 = 匹配代码定义变量(代码文本)
    # 变量列表2 = 提取导入变量(代码文本)
    # 变量列表3 = 固定语法匹配(代码文本)

    日志.debug(中文变量_集合)
    合并后变量_字典 = 查询并合并变量(中文变量_集合)
    中文变量映射 = {变量: 合并后变量_字典[变量] for 变量 in 中文变量_集合}
    # 替换只需要替换 `中文变量列表` 中的就可以了, 需要一个映射关系
    if 代码类型 == "py":
        代码文本 = 函数_替换代码变量(代码文本, 中文变量映射)
    elif 代码类型 == "ipynb":
        for cell in notebook['cells']:
            if cell['cell_type'] == 'code':
                source = ''.join(cell['source'])
                翻译代码 = 函数_替换代码变量(source, 中文变量映射)
                if isinstance(source, list):
                    cell['source'] = 翻译代码.splitlines(keepends=True)
                elif isinstance(source, str):
                    cell['source'] = 翻译代码

        # 保存修改后英文代码, 保存在同一个路径, 文件名称, 原来的中文文件名称翻译成一个英文的文件名称
    代码所在目录 = os.path.dirname(代码_绝对路径)
    # 提取文件名部分
    文件名 = os.path.basename(代码_绝对路径)
    文件名前缀, 文件名后缀 = 文件名.split(".")
    # 这里有可能文件名早就在已保存变量里面已经有了, 就不再需要翻译了.
    已保存变量 = 读取中英映射变量()
    if 文件名前缀 not in 已保存变量:
        文件名前缀_翻译字典 = 通义千问模型.翻译文件名(文件名前缀)
        文件名前缀_翻译结果 = 文件名前缀_翻译字典[文件名前缀]
        # 将翻译的结果也保存到变量中
        已保存变量.setdefault(文件名前缀, 文件名前缀_翻译字典[文件名前缀])
        保存中英变量(已保存变量)
    else:
        文件名前缀_翻译结果 = 已保存变量[文件名前缀]

    英文代码_保存路径 = 代码所在目录 + "/" + 文件名前缀_翻译结果 + "." + 文件名后缀
    with open(英文代码_保存路径, "w") as f:
        if 代码类型 == "py":
            f.write(代码文本)
        elif 代码类型 == "ipynb":
            json.dump(notebook, f, ensure_ascii=False, indent=4)
    return 英文代码_保存路径





def 代码文件翻译_特殊(代码_绝对路径):
    """__init__文件替换"""
    with open(代码_绝对路径, "r") as 文件:
        代码文本 = 文件.read()
    中文变量_集合 = 提取中文变量(代码文本, 引号=1)

    日志.debug(中文变量_集合)
    合并后变量_字典 = 查询并合并变量(中文变量_集合)
    中文变量映射 = {变量: 合并后变量_字典[变量] for 变量 in 中文变量_集合}
    # 替换只需要替换 `中文变量列表` 中的就可以了, 需要一个映射关系
    代码文本 = 函数_替换代码变量(代码文本, 中文变量映射, 引号=1)

    with open(代码_绝对路径, "w") as f:
        f.write(代码文本)



def 复制文件_覆盖(原目录, 目标目录):
    """将一个文件夹内容复制到另外一个文件夹中, 如果原来文件已经存在, 则覆盖掉同名文件"""
    if not os.path.exists(目标目录):
        os.makedirs(目标目录)

    for 文件 in os.listdir(原目录):
        源路径 = os.path.join(原目录, 文件)
        目标路径 = os.path.join(目标目录, 文件)

        if os.path.isdir(源路径):
            # 递归复制文件夹
            复制文件_覆盖(源路径, 目标路径)
        else:
            # 复制文件并覆盖
            shutil.copy2(源路径, 目标路径)


def 复制文件夹_删除已存在(原目录, 创建目录):
    """复制一个目录内容到新的目录, 如果原来"""
    if not os.path.exists(创建目录):
        shutil.copytree(原目录, 创建目录)
    else:  # 如果原来这个文件夹已经存在了? 那应该是希望重新翻译整个项目, 覆盖原来的翻译结果, 考虑到配置文件也可能会发生变化, 整个重新翻译吧
        shutil.rmtree(创建目录)
        shutil.copytree(原目录, 创建目录)


def 转换英文文件夹_到中文(项目_根路径):
    """函数功能: 将复制后的文件夹当中, 所有的英文文件夹, 重命名成中文"""

    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)
    收集_相对目录列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_目录列表]
    项目_目录表单 = pd.DataFrame(columns=["文件夹名称", "中文变量", "相对路径",
                                          "中文相对路径", "上层路径", "中文上层路径", "重命名记录", "上层修改标识", "包含中文"])
    id = 0

    for 相对路径 in 收集_相对目录列表:
        if 相对路径:  # 排除根路径
            上层路径, 文件夹名称 = 相对路径.rsplit("/", maxsplit=1)
            项目_目录表单.loc[id] = {
                "文件夹名称": 文件夹名称,
                "中文变量": "",
                "相对路径": 相对路径,
                "中文相对路径": 相对路径,
                "上层路径": 上层路径,
                "中文上层路径": 上层路径,
                "重命名记录": 0,
                "上层修改标识": 0,
                "包含中文": 0
            }

            if 判断中文变量(文件夹名称):  # 过滤带有中文的目录
                项目_目录表单.loc[id, "包含中文"] = 1
            elif 判断中文变量(项目_目录表单.loc[id, "相对路径"]):  # 上层包含中文
                项目_目录表单.loc[id, "包含中文"] = 2  # 包含中文为2
            id += 1

    项目_中文目录表单 = 项目_目录表单[项目_目录表单["包含中文"] == 1]
    项目_父目录中文表单 = 项目_目录表单[项目_目录表单["包含中文"] == 2]
    项目_纯英文目录表单 = 项目_目录表单[项目_目录表单["包含中文"] == 0]
    # 项目_纯英文目录表单 = 项目_目录表单

    # 合并后变量_字典 = 查询英文变量(变量列表_列表)
    合并后变量 = 查询英文变量_V1(项目_纯英文目录表单["文件夹名称"].to_list())

    for 索引 in 项目_纯英文目录表单.index:
        项目_目录表单.loc[索引, "中文变量"] = 合并后变量[项目_纯英文目录表单.loc[索引, "文件夹名称"]]

    for 索引 in 项目_纯英文目录表单.index:
        # 直接创建该文件夹, 如果没有上层修改标识, 代表这个目录的上层都是英文的, 或者是第一层文件夹
        文件夹名称 = 项目_目录表单.loc[索引, "文件夹名称"]
        中文上层路径 = 项目_目录表单.loc[索引, "中文上层路径"]
        创建目录 = 项目_根路径 + "/" + 中文上层路径 + "/" + 项目_目录表单.loc[索引, "中文变量"]
        原目录 = 项目_根路径 + "/" + 中文上层路径 + "/" + 文件夹名称
        # 这里有可能并没有成功翻译成中文, 所以中文变量, 和原来的英文变量是一样的, 导致报错
        项目_目录表单.loc[索引, "中文相对路径"] = 项目_目录表单.loc[索引, "中文相对路径"].replace(
            文件夹名称,
            合并后变量[文件夹名称])
        # 当没有翻译成功, 两个目录相同时, 如何处理? 出现了小写翻译成了大写, 应该判断翻译后和翻以前是否存在不同
        if 项目_目录表单.loc[索引, "中文变量"] != 文件夹名称 and 项目_目录表单.loc[
            索引, "中文变量"].lower() != 文件夹名称.lower():
            # if 判断中文变量(项目_目录表单.loc[索引, "中文变量"]):
            if not os.path.exists(创建目录):
                os.rename(原目录, 创建目录)  # 将中文文件夹重命名成英文文件夹
            else:
                复制文件_覆盖(原目录, 创建目录)
                shutil.rmtree(原目录)

        # 这里要对所有该目录的子目录的 "中文相对路径", "中文上层路径" 进行修改
        # 这个地方出现问题了, 在英文里面没有出现问题, 为什么在这这里出问题了呢? 中文相对路径, 应该是翻译之后的路径
        # 相对路径, 应该是原来的英文路径.
        # 判断内层文件夹是不是归属于上层文件夹, 应该用?
        for 索引_内层 in 项目_目录表单.index:
            if 索引 != 索引_内层:  # 如果不是当前处理目录
                if 判断子目录(项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引_内层, "相对路径"]):
                    # 上层目录修改过, 标记一下
                    项目_目录表单.loc[索引_内层, "上层修改标识"] = 1  # 没用了
                    项目_目录表单.loc[索引_内层, "中文相对路径"] = 项目_目录表单.loc[
                        索引_内层, "相对路径"].replace(
                        项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引, "中文相对路径"])

                    项目_目录表单.loc[索引_内层, "中文上层路径"] = 项目_目录表单.loc[
                        索引_内层, "上层路径"].replace(
                        项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引, "中文相对路径"])

    # 项目_目录表单.update(项目_纯英文目录表单)
    # 转换import 引用路径 /bot/baidu 变成  bot.baidu
    项目_目录表单["引用路径_英文"] = 项目_目录表单.相对路径.str.strip("/").str.replace("/", ".")
    项目_目录表单["引用路径_中文"] = 项目_目录表单.中文相对路径.str.strip("/").str.replace("/", ".")

    return 项目_目录表单

def 重构英文文件夹(项目_根路径):
    """函数功能: 这个新代码是配合Rope重构的功能, 提取出全部的英文文件夹之后, 将文件夹翻译成中文, 然后py代码中所有引用的地方.
    也都需要进行对应的重构, 保证代码仍然能够正常运行.
    1. 提取全部文件夹, 过滤其中的英文文件夹.
    2. 获取英文文件夹的翻译结果
    3. 对文件夹进行重命名, 然后遍历py文件, 对所有py文件中引用了文件夹的 from xxx 代码进行修改.

    如果是import 文件夹,   说明该文件夹中应该是有__init__.py代码, 那么对于这种的话, 可能要单独判断是否文件夹, 还是py代码.
    例如有一个config文件夹, 在同一层级还有一个config.py文件, 那么import config到底导入的是哪个呢?
    测试结果是先导入config.py, 所以这两个还真的会冲突.

    """

    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)
    收集_相对目录列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_目录列表]
    项目_目录表单 = pd.DataFrame(columns=["文件夹名称", "中文变量", "相对路径",
                                          "中文相对路径", "上层路径", "中文上层路径", "重命名记录", "上层修改标识", "包含中文"])
    id = 0

    for 相对路径 in 收集_相对目录列表:
        if 相对路径:  # 排除根路径
            上层路径, 文件夹名称 = 相对路径.rsplit("/", maxsplit=1)
            项目_目录表单.loc[id] = {
                "文件夹名称": 文件夹名称,
                "中文变量": "",
                "相对路径": 相对路径,
                "中文相对路径": 相对路径,
                "上层路径": 上层路径,
                "中文上层路径": 上层路径,
                "重命名记录": 0,
                "上层修改标识": 0,
                "包含中文": 0
            }

            if 判断中文变量(文件夹名称):  # 过滤带有中文的目录
                项目_目录表单.loc[id, "包含中文"] = 1
            elif 判断中文变量(项目_目录表单.loc[id, "相对路径"]):  # 上层包含中文
                项目_目录表单.loc[id, "包含中文"] = 2  # 包含中文为2
            id += 1

    项目_中文目录表单 = 项目_目录表单[项目_目录表单["包含中文"] == 1]
    项目_父目录中文表单 = 项目_目录表单[项目_目录表单["包含中文"] == 2]
    项目_纯英文目录表单 = 项目_目录表单[项目_目录表单["包含中文"] == 0]
    # 项目_纯英文目录表单 = 项目_目录表单

    # 合并后变量_字典 = 查询英文变量(变量列表_列表)
    翻译导入变量映射字典 = 过滤并查询英文变量_V2(项目_纯英文目录表单["文件夹名称"].to_list())
    # 合并后变量 = 查询英文变量_V1(项目_纯英文目录表单["文件夹名称"].to_list())
    # 如果某个单词翻译之后, 仍然是全英文的, 或者是, 和原来的单词小写值是一致的, 说明该单词不需要改变, 仍然保留原来的值

    for 索引 in 项目_纯英文目录表单.index:
        翻译单词 = 翻译导入变量映射字典.get(项目_纯英文目录表单.loc[索引, "文件夹名称"])
        # 三种可能, 没有翻译结果(过滤掉了, 例如a, .github), 翻译结果和原来的一样, 翻译结果变成大写单词.
        if 翻译单词 and 翻译单词 != 项目_目录表单.loc[索引, "文件夹名称"] and 翻译单词.lower() != 项目_目录表单.loc[索引, "文件夹名称"].lower():
            项目_目录表单.loc[索引, "中文变量"] = 翻译导入变量映射字典[项目_纯英文目录表单.loc[索引, "文件夹名称"]]

    for 索引 in 项目_纯英文目录表单.index:
        # 直接创建该文件夹, 如果没有上层修改标识, 代表这个目录的上层都是英文的, 或者是第一层文件夹
        if (not 项目_目录表单.loc[索引, "中文变量"]) or (项目_目录表单.loc[索引, "相对路径"].find(r"/.") >= 0):
            continue
        文件夹名称 = 项目_目录表单.loc[索引, "文件夹名称"]
        中文上层路径 = 项目_目录表单.loc[索引, "中文上层路径"]
        # 如果上层路径中包含 "/." 则说明是在隐藏文件夹当中, 不进行翻译

        创建目录 = 项目_根路径 + "/" + 中文上层路径 + "/" + 项目_目录表单.loc[索引, "中文变量"]
        原目录 = 项目_根路径 + "/" + 中文上层路径 + "/" + 文件夹名称
        # 这里有可能并没有成功翻译成中文, 所以中文变量, 和原来的英文变量是一样的, 导致报错
        项目_目录表单.loc[索引, "中文相对路径"] = 项目_目录表单.loc[索引, "中文相对路径"].replace(
            文件夹名称,
            翻译导入变量映射字典[文件夹名称])
        # 当没有翻译成功, 两个目录相同时, 如何处理? 出现了小写翻译成了大写, 应该判断翻译后和翻以前是否存在不同
        # 重命名该文件夹
        if not os.path.exists(创建目录):
            os.rename(原目录, 创建目录)  # 将中文文件夹重命名成英文文件夹
            项目_目录表单.loc[索引, "重命名记录"] = 1

                # 这里要对所有该目录的子目录的 "中文相对路径", "中文上层路径" 进行修改
        # 这个地方出现问题了, 在英文里面没有出现问题, 为什么在这这里出问题了呢? 中文相对路径, 应该是翻译之后的路径
        # 相对路径, 应该是原来的英文路径.
        # 判断内层文件夹是不是归属于上层文件夹, 应该用?
        for 索引_内层 in 项目_目录表单.index:
            if 索引 != 索引_内层:  # 如果不是当前处理目录
                if 判断子目录(项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引_内层, "相对路径"]):
                    # 上层目录修改过, 标记一下
                    项目_目录表单.loc[索引_内层, "上层修改标识"] = 1  # 没用了
                    项目_目录表单.loc[索引_内层, "中文相对路径"] = 项目_目录表单.loc[
                        索引_内层, "相对路径"].replace(
                        项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引, "中文相对路径"])

                    项目_目录表单.loc[索引_内层, "中文上层路径"] = 项目_目录表单.loc[
                        索引_内层, "上层路径"].replace(
                        项目_目录表单.loc[索引, "相对路径"], 项目_目录表单.loc[索引, "中文相对路径"])


    # 项目_目录表单.update(项目_纯英文目录表单)
    # 转换import 引用路径 /bot/baidu 变成  bot.baidu
    项目_目录表单["引用路径_英文"] = 项目_目录表单.相对路径.str.strip("/").str.replace("/", ".")
    项目_目录表单["引用路径_中文"] = 项目_目录表单.中文相对路径.str.strip("/").str.replace("/", ".")

    return 项目_目录表单

def 代码导包目录翻译(项目_根路径, 代码_相对路径, 项目_目录表单, 项目_py文件表单):
    # 项目_根路径, 项目_py文件表单.loc[索引, "相对路径"], rope管理 代码_绝对路径
    """翻译代码中from xxx import xxx中和目录相关的代码"""
    代码_绝对路径 = 项目_根路径 + 代码_相对路径
    if 代码_绝对路径.endswith(".py"):
        代码类型 = "py"
    elif 代码_绝对路径.endswith(".ipynb"):
        代码类型 = "ipynb"

    if 代码类型 == "py":
        with open(代码_绝对路径, "r") as 文件:
            代码文本 = 文件.read()
    elif 代码类型 == "ipynb":
        with open(代码_绝对路径, 'r', encoding='utf-8') as file:
            notebook = json.load(file)
            代码文本 = ipynb转换成py(notebook)


    # 替换只需要替换 `中文变量列表` 中的就可以了, 需要一个映射关系
    if 代码类型 == "py":
        导入变量表格: pd.DataFrame = 提取导入变量_行号(代码文本)
    elif 代码类型 == "ipynb":
        for cell in notebook['cells']:
            if cell['cell_type'] == 'code':
                source = ''.join(cell['source'])
                # Todo 未完成编写
                导入变量表格: pd.DataFrame = 提取导入变量_行号(source)

    # 所有首先判断是不是目录, 如果不是在判断是不是py文件
    # 翻译from代码, 在项目_目录表单, 和项目_py文件表单中有文件和目录的数据, 一次性翻译完成? 如果是from则
    for index in 导入变量表格.index:
        from变量 = 导入变量表格.loc[index, "from变量"]
        if from变量 in 项目_目录表单.引用路径_英文.values:  # 说明是项目内的路径
            引用路径_中文 = 项目_目录表单.loc[项目_目录表单.引用路径_英文 == from变量, "引用路径_中文"]
            from拆分_列表 = 导入变量表格.loc[index, "from拆分"]
            目录列表 = from变量.split(".")
            翻译目录列表 = 引用路径_中文.iloc[0].split(".")
            for i in range(len(目录列表)):
                from拆分_列表[i][1] = 翻译目录列表[i]

        elif from变量 in 项目_py文件表单.原英文引用路径.values:
            # key是common.log 这里 引用目录是 common, log.py文件 key: common value: 通用
            引用目录 = 项目_py文件表单.loc[项目_py文件表单.原英文引用路径 == from变量, "引用目录"]
            if 引用目录.shape[0] == 1:
                引用目录 = 引用目录.iloc[0]
                目录列表 = from变量.split(".")[:-1]
                from拆分_列表 = 导入变量表格.loc[index, "from拆分"]
                翻译目录列表 = 引用目录.split(".")
                for i in range(len(目录列表)):
                    from拆分_列表[i][1] = 翻译目录列表[i]

        import变量 = 导入变量表格.loc[index, "import变量"]
        # 有了一个import变量, 下一步判断是否文件夹, 如果是文件夹则进行替换
        if import变量 in 项目_目录表单.引用路径_英文.values:  # 说明是项目内的路径
            引用路径_中文 = 项目_目录表单.loc[项目_目录表单.引用路径_英文 == import变量, "引用路径_中文"].iloc[0]
            导入变量表格.at[index, "import变量翻译"].append([import变量, 引用路径_中文])

        if import变量 in 项目_py文件表单.原英文引用路径.values:
            引用目录 = 项目_py文件表单.loc[项目_py文件表单.原英文引用路径 == import变量, "引用目录"]
            if 引用目录.shape[0] == 1:
                引用目录 = 引用目录.iloc[0]
                目录列表 = import变量.split(".")[:-1]
                import变量翻译_列表 = []
                翻译目录列表 = 引用目录.split(".")
                for i in range(len(目录列表)):
                    import变量翻译_列表.append([目录列表[i], 翻译目录列表[i]])
                导入变量表格.at[index, "import变量翻译"].extend(import变量翻译_列表)

    代码文本_列表 = 代码文本.splitlines(keepends=True)
    for 变量列表 in 导入变量表格.from拆分.drop_duplicates().values:
        for i in 变量列表:
            原单词 = i[0]
            翻译单词 = i[1]
            if 翻译单词:
                本行代码 = 代码文本_列表[i[2] - 1]
                # 替换本行代码
                代码文本_列表[i[2] - 1] = 本行代码.replace(原单词, 翻译单词, 1)

    for index in 导入变量表格.index:
        import变量翻译_列表 = 导入变量表格.loc[index, "import变量翻译"]
        for i in import变量翻译_列表:
            原单词 = i[0]
            翻译单词 = i[1]
            行号 = 导入变量表格.loc[index, "行号"]
            本行代码 = 代码文本_列表[行号 - 1]
            代码文本_列表[行号 - 1] = 本行代码.replace(原单词, 翻译单词, 1)

    代码文本 = "".join(代码文本_列表)

    with open(代码_绝对路径, "w") as f:
        if 代码类型 == "py":
            f.write(代码文本)
        elif 代码类型 == "ipynb":
            json.dump(notebook, f, ensure_ascii=False, indent=4)

def 重构文件夹对应py代码(项目_根路径, 项目_目录表单):
    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)
    收集_相对目录列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_目录列表]  # 有了创建文件夹之后的, 目录列表, 如何判断呢?
    收集_相对文件列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_文件列表]

    日志.info(收集_相对目录列表)
    日志.info(收集_相对文件列表)

    项目_文件表单 = pd.DataFrame(columns=["文件名称", "英文变量", "相对路径",
                                          "英文相对路径", "上层路径", "英文上层路径", "上层修改标识", "py代码", "引用路径", "引用目录", "引用文件"])

    id = 0

    for 相对路径 in 收集_相对文件列表:
        上层路径, 文件名称 = 相对路径.rsplit("/", maxsplit=1)
        项目_文件表单.loc[id] = {
            "文件名称": 文件名称,
            "英文变量": "",
            "相对路径": 相对路径,
            "英文相对路径": 相对路径,
            "上层路径": 上层路径,
            "英文上层路径": 上层路径,
            "上层修改标识": 0,
            "py代码": 0,
            "引用路径": "",
            "引用目录": "",
            "引用文件": ""
        }
        相对路径_处理 = 相对路径[1:]
        if 文件名称.find(".py") > -1 or 文件名称.find(".ipynb") > -1:  # 过滤带有中文的目录
            项目_文件表单.loc[id, "py代码"] = 1
            if 相对路径_处理.endswith("__init__.py"):
                项目_文件表单.loc[id, "引用路径"] = 相对路径_处理.replace("/__init__.py", "").replace("/", ".")
                项目_文件表单.loc[id, "引用目录"] = 相对路径_处理.replace("/__init__.py", "").replace("/", ".")
                项目_文件表单.loc[id, "引用文件"] = "__init__.py"
            else:
                项目_文件表单.loc[id, "引用路径"] = 相对路径_处理.replace("/", ".").removesuffix(".py")
                if 相对路径_处理.find("/") >= 0:
                    项目_文件表单.loc[id, "引用目录"], 项目_文件表单.loc[id, "引用文件"] = 相对路径_处理.replace("/", ".").removesuffix(".py").rsplit(".", 1)
                else:
                    项目_文件表单.loc[id, "引用文件"] = 相对路径_处理.replace("/", ".").removesuffix(".py")

        id += 1

    # 合并两个表 引用路径_中文, 引用目录
    项目_文件表单 = pd.merge(项目_文件表单, 项目_目录表单[["引用路径_英文", "引用路径_中文"]],
                             left_on="引用目录",
                             right_on="引用路径_中文", how="left", suffixes=("", "_目录表单"))
    项目_文件表单.pop("引用路径_中文")
    项目_文件表单.rename(columns={"引用路径_英文": "引用目录_英文"}, inplace=True)
    项目_文件表单["原英文引用路径"] = 项目_文件表单["引用目录_英文"] + "." + 项目_文件表单["引用文件"]

    项目_py文件表单 = 项目_文件表单.loc[项目_文件表单["py代码"] == 1]  # 切片视图
    日志.debug(项目_py文件表单)

    for 索引 in 项目_py文件表单.index:
        # 对每个代码进行翻译, 应该提取出代码中的 from 后面的内容, 和import的内容
        代码导包目录翻译(项目_根路径, 项目_py文件表单.loc[索引, "相对路径"], 项目_目录表单, 项目_py文件表单)



def 全项目代码翻译(项目_根路径):
    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)
    收集_相对目录列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_目录列表]  # 有了创建文件夹之后的, 目录列表, 如何判断呢?
    收集_相对文件列表 = [元素.replace(项目_根路径, "") for 元素 in 收集_文件列表]

    日志.info(收集_相对目录列表)
    日志.info(收集_相对文件列表)

    # 分析目录之间的中英文映射关系
    中文路径映射关系 = {}
    已保存变量 = 读取中英映射变量()
    for 目录 in 收集_相对目录列表:
        目录组成_列表 = 目录.split("/")
        if 过滤中文变量(目录组成_列表):
            翻译英文路径 = "/".join([已保存变量[i] if 判断中文变量(i) else i for i in 目录组成_列表])
            中文路径映射关系[目录] = 翻译英文路径

    项目_文件表单 = pd.DataFrame(columns=["文件名称", "英文变量", "相对路径",
                                          "英文相对路径", "上层路径", "英文上层路径", "上层修改标识"])

    id = 0

    for 相对路径 in 收集_相对文件列表:
        上层路径, 文件名称 = 相对路径.rsplit("/", maxsplit=1)
        项目_文件表单.loc[id] = {
            "文件名称": 文件名称,
            "英文变量": "",
            "相对路径": 相对路径,
            "英文相对路径": 相对路径,
            "上层路径": 上层路径,
            "英文上层路径": 上层路径,
            "上层修改标识": 0,
            "包含中文": 0
        }
        if 判断中文变量(文件名称) and (文件名称.find(".py") > -1 or 文件名称.find(".ipynb") > -1):  # 过滤带有中文的目录
            项目_文件表单.loc[id, "包含中文"] = 1
        id += 1

    项目_中文文件表单 = 项目_文件表单.loc[项目_文件表单["包含中文"] == 1]  # 切片视图
    日志.debug(项目_中文文件表单)

    for 索引 in 项目_中文文件表单.index:
        # 索引全部是中文py文件,
        上层路径 = 项目_中文文件表单.loc[索引, "上层路径"]
        if 上层路径 == "":  # 项目根路径中, 直接翻译
            英文代码_保存路径 = 代码文件翻译_V2(项目_根路径 + "/" + 项目_中文文件表单.loc[索引, "相对路径"])  # 翻译成英文
        elif 判断中文变量(上层路径):  # 判断所在路径如果存在中文, 则应该有对应的英文路径, 不用处理
            pass
        else:  # 全部是英文的路径, 看看有没有对应映射
            if 上层路径 in 中文路径映射关系.values():  # 有映射关系, 说明是衍生文件夹, 应该翻译后删除
                英文代码_保存路径 = 代码文件翻译_V2(
                    项目_根路径 + "/" + 项目_中文文件表单.loc[索引, "相对路径"])  # 翻译成英文
                # 删除对应中文
                os.remove(项目_根路径 + "/" + 项目_中文文件表单.loc[索引, "相对路径"])
            else:  # 原生英文文件夹, 里面的内容应该翻译, 原来的保留.
                英文代码_保存路径 = 代码文件翻译_V2(
                    项目_根路径 + "/" + 项目_中文文件表单.loc[索引, "相对路径"])  # 翻译成英文

    # 应该有很多目录, 我要判断一个目录当中, 中英文的映射关系, 如果是有映射的, 那么就应该对其中的中文进行翻译, 然后删除.
    # 如果是没有映射的, 那么就应该翻译然后保留, 反正只要是在有映射对象的中文, 一定要翻译.

    # 反之, 如果是在中文目录当中, 如果有英文映射目录, 那么不需要翻译.
    # 如果没有英文映射, 那是不可能的说明文件夹出错了.

    # 如果在根目录, 翻译并且保留.

    # 不对啊,
    # '/Users/yangxinyi/Downloads/Test_Translate_Project/example/novel_send/小说_发送_脚本.py',
    # '/Users/yangxinyi/Downloads/Test_Translate_Project/示例代码/novel_send/小说_发送_脚本.py',
    # 现在对于某些代码, 已经有过复制了, 对于有复制记录的, 应该翻译复制之后的,
    # 对于没有复制记录的, 应该翻译原来的, 所以需要判断是否有过翻译记录
    # 1. 提取出 "相对路径" 序列, 如果在这里, 就不处理
    # 2. 提取出 "'英文相对路径'" 序列, 如果在这里, 就替换
    # 3. 如果不在这两个当中, 就是原生的, 创建一个新的英文版本, 原来的保留.

    项目_文件表单.update(项目_中文文件表单)

    for 索引 in 项目_文件表单.index:
        if 项目_文件表单.loc[索引, "文件名称"] == "__init__.py":
            # 判断上层是中文还是英文
            上层文件夹 = 项目_文件表单.loc[索引, "上层路径"].rsplit("/", maxsplit=1)[-1]
            if not 判断中文变量(上层文件夹):  # 上层是英文文件夹, 对这个文件中的内容进行翻译.
                代码文件翻译_特殊(项目_根路径 + "/" + 项目_文件表单.loc[索引, "相对路径"])

    return 项目_文件表单


def 复制项目代码翻译(项目_根路径, 项目_翻译路径):
    # 这是翻译过文件漫威的目标列表
    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_翻译路径)
    收集_相对目录列表 = [元素.replace(项目_翻译路径, "") for 元素 in 收集_目录列表]  # 有了创建文件夹之后的, 目录列表, 如何判断呢?
    收集_相对文件列表 = [元素.replace(项目_翻译路径, "") for 元素 in 收集_文件列表]

    日志.info(收集_相对目录列表)
    日志.info(收集_相对文件列表)

    项目_文件表单 = pd.DataFrame(columns=["文件名称", "中文变量", "英文相对路径",
                                          "中文相对路径", "英文上层路径", "中文上层路径",
                                          "翻译英文变量", "英中变量映射",
                                          "上层修改标识", "翻译文件"], dtype='object'
                                 )

    id = 0

    for 相对路径 in 收集_相对文件列表:
        上层路径, 文件名称 = 相对路径.rsplit("/", maxsplit=1)
        项目_文件表单.loc[id] = {
            "文件名称": 文件名称,
            "中文变量": "",
            "英文相对路径": "",
            "中文相对路径": 相对路径,
            "英文上层路径": "",
            "中文上层路径": 上层路径,
            "翻译英文变量": {},
            "英中变量映射": {},
            "上层修改标识": 0,
            "翻译文件": 0
        }
        if (not 判断中文变量(文件名称)) and (文件名称.find(".py") > -1 or 文件名称.find(".ipynb") > -1):  # 过滤带有中文的目录
            项目_文件表单.loc[id, "翻译文件"] = 1
        id += 1

    # 和目录进行交集运算, 计算出未翻译之前的路径
    项目_目录表单.中文相对路径 = 项目_目录表单.中文相对路径.str.lower()
    项目_目录表单.相对路径 = 项目_目录表单.相对路径.str.lower()
    项目_文件表单.中文上层路径 = 项目_文件表单.中文上层路径.str.lower()
    项目_文件表单 = pd.merge(项目_文件表单, 项目_目录表单[["中文相对路径", "相对路径"]], left_on="中文上层路径",
                             right_on="中文相对路径", how="left", suffixes=("", "_目录表单"))
    项目_文件表单["英文上层路径"] = 项目_文件表单["相对路径"]
    项目_文件表单.英文上层路径 = 项目_文件表单.英文上层路径.fillna("")
    项目_文件表单["英文相对路径"] = 项目_文件表单.英文上层路径 + "/" + 项目_文件表单.文件名称
    # 项目_文件表单.pop("相对路径")

    项目_翻译文件表单 = 项目_文件表单.loc[项目_文件表单["翻译文件"] == 1]  # 切片视图

    # 将提取和翻译变量变成一个函数, 不能所有都提取完了再翻译, 大模型恐怕处理不了那么多, 上千个变量.
    # 也不一定吧, 万一是能处理的呢? 先试试一口气全部处理的方案. 不行再改成一个一个的处理.
    全部提取变量_集合 = set()
    for 索引 in 项目_文件表单.index:
        原代码路径 = 项目_文件表单.loc[索引, "英文相对路径"]
        if 项目_文件表单.loc[索引, "翻译文件"] == 1:
            提取变量_集合 = 代码变量提取(原代码路径, 项目_根路径, 项目_文件表单, 项目_目录表单)
            项目_文件表单.at[索引, "翻译英文变量"] = 提取变量_集合
            全部提取变量_集合.update(提取变量_集合)

    日志.debug("提取变量个数: {}", len(全部提取变量_集合))
    全部提取变量_字典 = 查询英文变量_V1(list(全部提取变量_集合))  # 计算翻译变量的函数
    已保存变量 = 读取中英映射变量()
    英文变量字典 = 翻转字典_调转(已保存变量)

    for 索引 in 项目_文件表单.index:
        # 文件名称 = 项目_文件表单.loc[索引, "文件名称"]
        代码相对路径 = 项目_文件表单.loc[索引, "中文相对路径"]
        if 项目_文件表单.loc[索引, "翻译文件"] == 1:
            # 将英文变量对应的中文变量提取出来, 形成"翻译变量映射" 字段
            翻译英文变量 = 项目_文件表单.loc[索引, "翻译英文变量"]
            英中变量映射 = {变量: 全部提取变量_字典[变量] for 变量 in 翻译英文变量}
            项目_文件表单.at[索引, "英中变量映射"] = 英中变量映射

            文件名称映射 = 代码文件翻译_V1(代码相对路径, 项目_翻译路径, 英中变量映射, 英文变量字典)
            if 文件名称映射:
                # 将翻译的结果也保存到变量中
                英文变量字典.update(文件名称映射)

            # 删除原来文件
            os.remove(项目_翻译路径 + "/" + 代码相对路径)
    中英变量词典 = 翻转字典_调转(英文变量字典)
    保存中英变量(中英变量词典)


def 开始翻译_英文项目(项目_根路径, 项目_翻译路径):
    设置状态值("开始重构英文文件夹...")
    复制文件夹_删除已存在(项目_根路径, 项目_翻译路径)
    项目_目录表单 = 重构英文文件夹(项目_翻译路径)
    设置状态值("翻译文件夹中...")
    重构文件夹对应py代码(项目_翻译路径, 项目_目录表单)
    设置进度值(10)
    设置状态值("文件夹翻译完成")
    git管理员 = Git管理(项目_翻译路径)
    git管理员.添加所有文件到git()
    git管理员.提交文件("提交所有文件")
    设置状态值("git提交文件")


    rope管理 = Rope管理器(项目_翻译路径)
    设置状态值("翻译py文件...")
    rope管理.批量修改py文件名称()

    设置进度值(20)

    设置状态值("提取python变量")
    for py文件 in rope管理.py文件列表:
        日志.debug(py文件)
        rope管理.创建资源(py文件)
        rope管理.获取监控范围()
        rope管理.提取导入变量()
        rope管理.提取范围变量()
    设置状态值("提取python变量完成")
    设置进度值(30)
    设置状态值("开始翻译python变量...")
    rope管理.过滤变量并翻译()
    rope管理.提取导入变量表格 = rope管理.处理重复变量(rope管理.提取导入变量表格)
    rope管理.提取变量表格 = rope管理.处理重复变量(rope管理.提取变量表格)
    设置状态值("翻译python变量完成")
    设置进度值(40)

    # 上面对所有文件资源进行处理, 这里仍然需要循环对所有进行处理, 虽然
    # rope管理.批量替换导入变量()

    rope管理.批量替换变量()
    设置状态值("python替换变量完成! 任务结束")

    return "ok"


if __name__ == '__main__':
    # 项目根目录的绝对路径
    # 项目_根路径 = '/Users/yangxinyi/Library/CloudStorage/OneDrive-个人/100_code/Test_Translate_Project'
    项目_根路径 = '/Users/yangxinyi/Downloads/200_临时文件夹/english_test_project'
    收集_目录列表, 收集_文件列表 = 遍历目录和文件列表(项目_根路径)

    # 待处理_代码路径 = "/Users/yangxinyi/Downloads/200_临时文件夹/english_test_project/bot/xunfei/abcd/test.py"
    # 代码文件翻译_V1(待处理_代码路径, 项目_根路径)

    # 关联文件判断(project_root)
    # 项目_中文目录表单, 项目_目录表单 = 创建英文文件夹(项目_根路径)
    # 日志.info(项目_中文目录表单)
    #
    # 项目_文件表单 = 全项目代码翻译(项目_根路径)
    #
    # 日志.info(项目_文件表单)
    # 日志.info(英文相对路径_列表)
    项目_翻译路径 = "/Users/yangxinyi/Downloads/200_临时文件夹/英文项目测试_20240919"
    复制文件夹_删除已存在(项目_根路径, 项目_翻译路径)
    # 项目_目录表单 = 转换英文文件夹_到中文(项目_翻译路径)

    # 接下来就是文件翻译, 文件当中的import要考虑到可能已经有部分文件夹翻译过了, 所以要根据代码当中的原路径进行判断.
    # 复制项目代码翻译(项目_根路径, 项目_翻译路径)

    项目_目录表单 = 重构英文文件夹(项目_翻译路径)
    重构文件夹对应py代码(项目_翻译路径, 项目_目录表单)

    git管理员 = Git管理(项目_翻译路径)
    git管理员.添加所有文件到git()
    git管理员.提交文件("提交所有文件")

    rope管理 = Rope管理器(项目_翻译路径)
    rope管理.批量修改py文件名称()


    for py文件 in rope管理.py文件列表:
        日志.debug(py文件)
        rope管理.创建资源(py文件)
        rope管理.获取监控范围()
        rope管理.提取导入变量()
        rope管理.提取范围变量()

    rope管理.过滤变量并翻译()
    rope管理.提取导入变量表格 = rope管理.处理重复变量(rope管理.提取导入变量表格)
    rope管理.提取变量表格 = rope管理.处理重复变量(rope管理.提取变量表格)

    # 上面对所有文件资源进行处理, 这里仍然需要循环对所有进行处理, 虽然
    # rope管理.批量替换导入变量()

    rope管理.批量替换变量()










